#!/usr/bin/perl -w
#
# Looks for bullet points and blockquotes
# in sections with title starting "Examples":
#
#  * `INPUT`: `OUTPUT`
#  * `INPUT` for struct: `OUTPUT`
#  * `INPUT` for structs: `OUTPUT`
#  * `INPUT` for enum: `OUTPUT`
#  * `INPUT` for enums: `OUTPUT`
#  * `INPUT` for enum variant: `OUTPUT`
#  * `INPUT` for enum variants: `OUTPUT`
#  * `INPUT` for `TYPE-OR-VARIANT`: `OUTPUT`
#  * `INPUT` for `FIELD` in `TYPE-OR-VARIANT`: `OUTPUT`
#
# Blockquotes ```rsut are tested separately via rustdoc, so ignored here.
#
# Otherwise, they should come in pairs, with, in between,
#   <!--##examples-for-toplevels-concat TYPE TYPE...##-->
# And then the first is expanded for each TYPE;
# the results (concatenated) must match the 2nd block.
#
# Special directives
#
#   <!--##examples-ignore##-->
#       Ignore until next blank line
#
#   <!--##examples-for FOO##-->
#       In bullet point(s), use this as if "for FOO" was written
#       (ignoring any actual "for FOO")
#       Applies until end of section (or next such directive)
#
# Preceding a ```...``` quote
#
#   <!--##examples-structs##-->
#       The quote has the example structs
#

use strict;
use JSON;

our $structs;
our %output;

our $bq_content;
our $bq_keywords;
our $inex_heading_hashes;
our $in_bullet;

# Reset at the end of each (sub)section
our $text_handle; # reset at end of para, too
our $override_for_clause;
our @t_limits; # used by handling of "for others:"
our $bq_type;
our $bq_input; # un-type-marked bq goes here until we know what to do with it
our @bq_toplevels; # examples-for-toplevels-concat

sub unhandled ($) {
  my ($what) = @_;
  chomp($what);
  warn "line $.,: unhandled $what\n";
}

sub in_example () {
  return defined $inex_heading_hashes;
}

our $o;

sub output_example ($$) {
  my ($kind, $data) = @_;
  push @{ $output{examples} }, {
      'line' => $.,
      'kind' => $kind,
      'data' => $data,
  };
}

sub handle_bullet ($) {
  local ($_) = @_;

  s{\n   +}{ }g;

  if (!m{^ \* `([^`]+)\`(?: for ([^:]+))?: (.*)$}) {
    chomp;
    unhandled("bullet point \"$_\"");
    return;
  }
  my ($input, $for_clause, $outputs) = ($1, $2, $3);

  my $t_limit;
  my $all_must_match = JSON::false;
  if (defined $override_for_clause) {
    $for_clause = $override_for_clause;
  }
  if (!defined $for_clause) {
    $t_limit = 'true';
  } else {
    local $_ = $for_clause;
    my $tv_name = sub {
      my ($n) = @_;
      sprintf "any(equal(\$tname,$n),all(is_enum,equal(\$vname,$n)))";
    };
    if (m{^structs?$}) {
      $t_limit = 'is_struct';
    } elsif (m{^enum( variant)?s?$}) {
      $t_limit = 'is_enum';
    } elsif (m{^\`(\w+)\`$}) {
      $t_limit = $tv_name->($1);
    } elsif (m{^`(\w+)` in \`(\w+)\`$}) {
      $t_limit = sprintf "all(equal(\$fname,%s),%s)", $1, $tv_name->($2);
      $all_must_match = JSON::true,
    } elsif (m{^others$}) {
      $t_limit = sprintf "not(any(%s))", join ',', @t_limits;
      $all_must_match = JSON::true,
    } else {
      unhandled("for clause \"$for_clause\"");
      $t_limit = 'false';
    }
  }

  push @t_limits, $t_limit;
  my $poss = sub {
    output_example
      'can_produce',
      {
       'input' => $input,
       'limit' => $t_limit,
       'all_must_match' => $all_must_match,
       'output' => $_[0],
      };
  };
  if ($outputs eq 'nothing') {
    $poss->('');
  } else {
    while (length $outputs) {
      if ($outputs !~ s{^\`([^\`]+)\`(?:, |$)}{}) {
	unhandled("(tail of) bullet point examples \"$outputs\"");
	last;
      }
      $poss->($1);
    }
  }
}

while (<STDIN>) {
  if (m{^\`\`\`}) {
    if (defined $bq_content) {
      if (!defined $bq_type) {
	if (!in_example()) {
	} elsif ($bq_keywords =~ m{^rust$}) {
	  # tested by rustdoc
	} elsif (@bq_toplevels) {
	  die unless defined $bq_input;
	  output_example
	    'concatenate_for',
	    {
	     'input' => $bq_input,
	     'toplevels' => \@bq_toplevels,
	     'output' => $bq_content,
	    };
	  @bq_toplevels = ();
	  $bq_input = undef;
	} elsif (defined $bq_input) {
	  unhandled('2nd unmarked blockquote');
	  $bq_input = undef;
	} else {
	  $bq_input = $bq_content;
	}
      } elsif ($bq_type eq 'structs') {
	die if defined $structs;
	$structs = $bq_content;
      } else {
	die "$bq_type ?";
      }
      $bq_type = undef;
      $bq_content = undef;
    } else {
      $bq_content = '';
      $bq_keywords = $';
    }
    next;
  }
  if (defined $bq_content) {
    $bq_content .= $_;
    next;
  }
  if (m{^\<\!--\#\#examples-(structs)\#\#--\>\s*$}) {
    die if $bq_type;
    $bq_type = $1;
    next;
  }
  if (m{^\<\!--\#\#examples-for ([^\#]+)\#\#--\>\s*$}) {
    $override_for_clause = $1;
    next;
  }
  if (m{^\<\!--\#\#examples-ignore\#\#--\>\s*$}) {
    $text_handle = 'ignore';
    next;
  }
  if (m{^\<\!--\#\#examples-for-toplevels-concat (\S[\w\s]+)\#\#--\>\s*$}) {
    if (!defined($bq_input)) {
      unhandled('xamples-for-toplevels-concat without input bq');
    } elsif (@bq_toplevels) {
      unhandled('ultiple xamples-for-toplevels-concat');
    } else {
      @bq_toplevels = grep m/\S/, split /\s+/, $1;
    }
    $text_handle = 'ignore';
    next;
  }
  if (m{^\#}) {
    $text_handle = undef;
    $override_for_clause = undef;

    @t_limits = ();
    if (defined $bq_input) {
      unhandled('unmarked blockquote with no output definition');
    }

    if (defined($bq_type)) {
      unhandled("missing mblockquote type $bq_type");
    }
    $bq_type = undef;

    if (defined($bq_input) || @bq_toplevels) {
      unhandled("missing 2nd mblockquote example");
    }
    $bq_input = undef;
    @bq_toplevels = ();
  }

  if (m{^$}) {
    $text_handle = undef;
  }

  if (defined($inex_heading_hashes) &&
      m{^\#(?!\Q$inex_heading_hashes\E)\#}) {
    $inex_heading_hashes = undef;
    next;
  }
  if (!defined($inex_heading_hashes)) {
    if (m{^(\#{3,}) Examples?\b}) {
      $inex_heading_hashes = $1;
    }
    next;
  }

  next if m{^\#};

  if (defined($in_bullet) && m{^   +\S}) {
    $in_bullet .= $_;
    next;
  }
  if (defined($in_bullet)) {
    if (in_example()) {
      my $org_line_no = $.; # want local but has magic to make it DTWT
      $. = $org_line_no-1;
      handle_bullet($in_bullet);
      $. = $org_line_no;
    }
    $in_bullet = undef;
  }
  die if defined $in_bullet;
  if (m{^ \* }) {
    $in_bullet = $_;
    next;
  } elsif (m{^\s*$}) {
    next;
  } elsif (m{^\<\!--##examples}) {
    unhandled("directive $_");
  } elsif (!defined($text_handle)) {
    unhandled("text in examples section: $_");
  } elsif ($text_handle eq 'ignore') {
  } else {
    die "$text_handle ?";
  }
}


$structs =~ s{^\#(?: |$)}{}mg;
$output{structs} = $structs;

my $encoder = new JSON;
$encoder->pretty(1);
$encoder->canonical(1);
print $encoder->encode(\%output) or die $!;
flush STDOUT or die $!;
