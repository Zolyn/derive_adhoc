# Future plans wrt macro namespace questions

## Deriving from things other than data structures

It would be nice to be able to eventually support deriving from
items (traits, fns, ...).  This would have to be an attribute proc macro.  Attribute proc macros get to modify their applicand, but we would not do that.

Ideally that attribute macro would be `#[derive_adhoc]`.  However:

 * We are already using that as an inert helper attribute for `#[derive(Adhoc)]`.  Possibly we could experiment to see how that would interact with a non-inert attribute macro, except that:

 * It is not possible to have an attribute macro and a function-like macro with the same name; even though the invocation syntaxes (and implementing macro function signatures) are different.

We are using `derive_adhoc!` for the main truly adhoc from-struct derivation.  I don't think we want to change that.  So we need a different name for the attribute macro.

## Proposed taxonomy of macros and attributes

We won't implement all of this right away,
but it is good to have a plan to make sure the names we take now
won't get in the way.

 * **`#[derive(Adhoc)]`**: invokes the from-struct derivation machinery; enables:
    1. use of `#[derive_adhoc(ReuseableMacro)]` on this very struct
    2. later use of `derive_adhoc!` of the same struct
    3. `#[adhoc(...)]` attributes on bits of the data structure

 * **`define_derive_adhoc!{ [pub] MACNAME = TEMPLATE }`**: define a reusable template, which may be invoked as `#[derive_adhoc(MACNAME)]` (within a struct annotated with `#[derive(Adhoc)]` or `#[item_derive_adhoc(MACNAME)]`.

 * **`derive_adhoc!{ DRIVERNAME: TEMPLATE }`**: truly-adhoc derivation from something previously annotated with `#[derive(Ahoc)]` or `#[item_derive_adhoc]`.  `DRIVERNAME` is an item path; we conflate the type and value namespaces.

 * **`#[item_derive_adhoc]`**: attribute macro to be applied to items.  The item is reproduced unchanged, except that `#[adhoc]` attributes *in places where we would look for them* are filtered out. `#[item_derive_adhoc(MACNAME)]` can be used to apply a reuseable template.

 * **`#[adhoc]`**: Inert helper attribute for `#[derive(Adhoc)]`.  Filtered-out attribute for `#[item_derive_adhoc]`.  Contents available via `$Xmeta`.

 * **`#[only_derive_adhoc]`**: attribute macro to be applied to items; like `#[item_derive_adhoc]` but *consumes and does not emit* the item.
   (We don't really need to be sure about this name; this will be an unusual case and we can give it whatever name seems good, later.)

### Internals

 * **`derive_adhoc_expand!`**: Proc macro that does all the work.

 * **`derive_adhoc_apply_DRIVERNAME!`**: `macro_rules` macro generated by `#[derive(Adhoc)]` and `#[item_derive_adhoc]`, embodying a driver.

 * **`derive_adhoc_call_MACNAME!`**: `macro_rules` macro generated by `define_derive_adhoc!`, embodying a template.
