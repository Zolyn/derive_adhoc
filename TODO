TEMPLATE FEATURES PLANNED
=========================

   String concatenation
		${string ...}
      Argument can contain any expansions,
      which will be expanded into tokens and stringified,
      and string literals (in " ").
      No un-quoted literal text is allowed.
      Expansion is a single string literal.
      FTAOD  ${string ${string "y"}}  =>  r#""y""#

   Case conversion
   Can be applied to names (only) within token or string concatenation:
      		$expansion:CASE
	Cases
      		lower upper snake camel		like in paste!
		pascal				like convert_case
		others may be added later
	Expansions
		Anything is allowed, $KEYWORD or ${...}
   So, eg,
      fn ${paste zingy_ $tname:snake _builder}();
   expands to
      fn zingy_foo_builder();

   Variant (or value) body and delimiter
	${vbody ... }		{ ... }		struct [variant] or union
				( ... )		tuple struct/variant
				nothing		unit struct/variant

   Field specifier
	$fspec			$fname :	in struct [variant] or union
				nothing		in tuple variant/struct


FEATURES WITH SYNTAX AND/OR SEMANTICS TBD
=========================================

   For things that need to split off fields        struct Foo as above {
   and talk only about subsets of the generics         field: Box<T>,
      generic parameter uses (for fields)
      		$fgens					T,
		$fgens_omitted				'l, C
      For explicit iteration, within ${for tgens ...} or $( ... )
		$tgname					'l   	T   	C
		$tgbounds ???

   Something for being able to handle structs/unions/enums
   equally in template, whatever that means.  We need to expand
   something to struct/union/enum, and possibly the brackets and
   commas in enum { ..., ..., }, and so on.

   Case conversion of general strings (ie non-name expansions
   within ${string }).


OTHER TODO LIST ITEMS
=====================

Proper docs
Sort out NOTES.md

A public writeup blog post


Bugs

 * Make things work if you have a normal crate that imports things
   in a normal way.

 * Ideally we would check the case of reuseable derive names.
   These should be in Pascal case.
   But we only want to *lint* for this, not fail, and that's hard.


Future-proofing: ensure we haven't painted ourselves into a corner for

   adhoc-derive from a trait, fn, impl block, ...

   Apply adhoc derive as an attribute macro, rather than derive macro,
   thus arranging that the decorated struct is not actually emitted?

   See FUTURE.md.


DEFERRED TODO LIST ITEMS
========================

Possibly, tests of compilation failures (but these are fragile
if done in the obvious way with trybuild).
