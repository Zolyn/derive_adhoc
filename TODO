TEMPLATE FEATURES PLANNED
=========================

   Handling of generics
      supposing				struct Foo<'l:'a, T:X, const C=1>
					where T: 'a
      generic bindings (ie with bounds)
		$tgens				'l:'a, T:X, const C=1,
      generic param names (without bounds)
		$tgnames			'l, T, C,
      where clauses (for toplevel)
		$twheres			T: 'a,
   (In each case with a trailing , after each one.)
   So you can write
       impl<$tgens> struct Bar<$tgnames> where $twheres {

   Token pasting
                ${paste ....}

      Argument contains expansions - only some allowed -
      and literal identifier chunks.

      Should be able to paste a type with prefix and suffixes,
      affecting the last path component.  Eg
		struct $[ $ttype Builder ] {
      should be able to generate
		struct crate::config::WombatBuilder<K> {

   String concatenation
		${string ...}
      Argument can contain any expansions, which will be stringified,
      and literals in " ".  No un-quoted literal text is allowed.
      Expansion is a single string literal.
      FTAOD  ${string ${string "y"}}  =>  r#""y""#

   Case conversion, applied to names within token pasting
   or string concatenation:
      		$expansion:CASE
	Cases
      		lower upper snake camel		like in paste!
		pascal				like convert_case
		others may be added later
	Expansions
		Anything is allowed, $KEYWORD or ${...}

   Variant (or value) body and delimiter
	${vbody  ....  }	{ ... }		struct [variant] or union
				( ... )		tuple struct/variant
				nothing		unit struct/variant

   Field specifier
	$fspec			$fname :	in struct [variant] or union
				nothing		in tuple variant/struct


FEATURES WITH SYNTAX AND/OR SEMANTICS TBD
=========================================

   For things that need to split off fields        struct Foo as above {
   and talk only about subsets of the generics         field: Box<T>,
      generic parameter uses (for fields)
      		$fgens					T,
		$fgens_omitted				'l, C
      For explicit iteration, within ${for tgens ...} or $( ... )
		$tgname					'l   	T   	C
		$tgbounds ???

   Something for being able to handle structs/unions/enums
   equally in template, whatever that means.  We need to expand
   something to struct/union/enum, and possibly the brackets and
   commas in enum { ..., ..., }, and so on.

   Case conversion of strings.


OTHER TODO LIST ITEMS
=====================

Proper docs
Sort out NOTES.md

A public writeup blog post


Bugs

 * Make results of define_derive_adhoc not exported.
   Make the macro encapsulating the struct body that #[derive(Adhoc)]
   generates not be #[macro_export] for now.

   (In the future we will change these.  It will be like this
	define_derive_adhoc!{ [pub] MACNAME = TEMPLATE }
   and
        https://gitlab.torproject.org/Diziet/rust-derive-adhoc/-/issues/1
   but see "Cross-crate API stability" in NOTES.md.)


 * Make things work if you have a normal crate that imports things
   in a normal way.

 * Ideally we would check the case of reuseable derive names.
   These should be in Pascal case.
   But we only want to *lint* for this, not fail, and that's hard.


Innards

   expand.rs is too big a file

   There is some flabbiness where code is repeated for different
   levels.



Future-proofing: ensure we haven't painted ourselves into a corner for

   adhoc-derive from a trait, fn, impl block, ...

   Apply adhoc derive as an attribute macro, rather than derive macro,
   thus arranging that the decorated struct is not actually emitted?

   See FUTURE.md.


DEFERRED TODO LIST ITEMS
========================

Possibly, tests of compilation failures (but these are fragile
if done in the obvious way with trybuild).
