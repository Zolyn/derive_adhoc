Notes on the syntaxes I'm using.

 ${} is used for _all_ "magic" expansions inside the define_derive_adhoc.
 The metasyntax is ${ident $(tt)*}

Magical expansions:

  ${when EXPR} -- Expands to no tokens when EXPR is true, and fails when EXPR
   is false.  Use inside $()?.

  ${if EXPR { .. } (elseif EXPR { ...})* (else { ... })?} Expands to the
    first block of tokens after the first expr that is true.  Expands to the
    else block if no exprs are true.  Expands to no tokens if no expr
    is true and there is no else.

  ${attr::PATH (as SYNTAX?)} expands to the string of tokens set in
    the attribute PATH, interpreted with SYNTAX.  If SYNTAX is absent,
    it defaults to "tt".



Expressions:

   EXPR ::=
      |  not(expr)
      |  all(expr)
      |  any(expr)

   EXPR ::= enum

      -- True iff the top-level type is an enum.

   EXPR ::= fattr(path)

      -- True iff there is an attribute present on a this field.
         For example, attr(a::b) is true whenever #[adhoc(a(b))] is
         present on the current field.

   EXPR ::= tattr(path)
          | vattr(path)

      -- Like fattr, but for toplevel attributes and variant attributes
         respectively.

  The value of an expression is "true", "false", or a sequence of tokens.
  All values except "false" count as semantically true.  Trying to
  interpolate "true" or "false" is an error.


Non-magical expansions:

 // On the top-level type:

 $ttype: The type of the object from which we're deriving, including
    parameters.
 $tname: The identifier for the object from which we're deriving, not
    including parameters.

 // on variants

 $vname : The name of the variant.  This fails to expand on a non-enum
 struct.

 // on fields
 $ftype : the type of a field of the object.

 $fname: The identifier of a field of the object.  This is 0,1,.. if this
     is a tuple struct.

